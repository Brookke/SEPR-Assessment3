<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB">
  <head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link href="https://teamfarce.github.io/MIRCH/style.css" rel="stylesheet" title="Default Stylesheet"/>
    <title>Murder in the Ron Cooke Hub - Testing</title>
    
  </head>
  <body>
    
    <header class="body-main-header">
      
      <h1 class="site-title">Murder in the Ron Cooke Hub</h1>
      <h2 class="page-title">Testing</h2>
      <nav class="main-site-nav">
        <ul>
          <li><a href="https://teamfarce.github.io/MIRCH/">Home</a></li>
          <li><a href="https://teamfarce.github.io/MIRCH/designdocs">Design Documentation</a></li>
          <li><a href="https://teamfarce.github.io/MIRCH/plan">Project Plan</a></li>
          <li><a href="https://teamfarce.github.io/MIRCH/code_docs">Code Documentation</a></li>
          <li><a href="https://teamfarce.github.io/MIRCH/testing">Code Tests</a></li>
          <li><a href="https://teamfarce.github.io/MIRCH/executable">Executable Downloads and User Manual</a></li>
          <li><a href="https://github.com/TeamFarce/MIRCH">Source Code/Git Repository</a></li>
        </ul>
      </nav>
      
    </header>
    <article class="body-main-article">
      

<h1>Testing</h1>

<p>We carried out various tests on our program to ensure that it functioned correctly in every eventuality.</p>

<h2>Unit Tests</h2>

<p>
As unit testing is White Box by design, we used this methodology to test each individual functional unit of our source code to ensure that it produces the desired logically correct output for every possible input. We generated unit tests for every logical component of our programs source code - i.e. functions and classes. Multiple unit tests can be generated for each logical component, so that we can test a wide variety of input data - including boundary data where required - to ensure that each component functions correctly by itself. This then allows us to be more confident that the program will function fully when the individual components are run together. 
</p>
<p>
We used the JUnit testing framework to build tests for our program - after building our Unit tests, they are run automatically every time the program is built, allowing us to continuously monitor our program for correctness and immediately identify any errors that may emerge. 
</p>

<p>
Results for our unit tests are auto-generated through are gradle build system and can be found <a href="UnitTests">here</a>.
</p>


<h2>Black Box Tests</h2>

<p>
We have designed a number of black box tests to ensure the external correctness of our program. These tests have been mostly based around the correct functionality of the user interface, as well as the game logic that these user interface elements enable. When designing these tests, we followed through every possible path in the program and listed every element that was present in these pathways. We then built black box tests around each of these elements to verify that they are functioning correctly and producing the logically correct output. This has allowed us to ensure that the UI of our program is fully usable and works in the desired way every time, as well as allowing us to identify any areas where the UI is less than complete and needs more work.
</p>

<p>
<a href="https://docs.google.com/spreadsheets/d/1_0ooEy3AGRgHsxxTVqezXOcVnum-3lz7OukJGtMkaVk/pubhtml?gid=0&amp;single=true&amp;widget=true&amp;headers=false">Black Box Test Results</a>
</p>


<h2>Acceptance Tests</h2>

<p>
We have made use of a series of binary result acceptance tests carried out from the end user's perspective using a Black Box methodology to ensure that our program has met its base requirements. When designing these acceptance tests, we looked at every requirement set out for our program, and tested every requirement possible whilst keeping within the bounds of Black Box Testing. Due to the black box nature of our acceptance testing we were unable to test for certain requirements, such as whether the selection of murderer and victim is truly random (which would involve white box testing) and others of a similar nature. Our use of Unit Tests has allowed us to ensure that these White Box tested requirements are still tested for correctness, therefore we can be confident that we are still meeting these requirements, however these tests are obviously therefore not included in our Acceptance Test results.
</p>
<p>
Our use of acceptance tests has allowed us to ensure that our program is being checked for nearly all functional requirements - allowing us to see which requirements have been passed and which requirements have been missed and still need to be included. Acceptance testing has therefore been very useful to us as it has provided us with an additional means of logging progress towards the end goal of a completed program.
</p>
<p>
<a href="https://docs.google.com/spreadsheets/d/1DdSSdp4tSuWlYOTbtcydhAwQijDavGrNyVCC-lpRogQ/pubhtml?gid=0&amp;single=true&amp;widget=true&amp;headers=false">Acceptance Test Results</a>
</p>

<h2>Report of Tests and Results</h2>
<p>
A report of our tests and test results can be found <a href="https://docs.google.com/document/d/1cNp0TBJ_fqQI8DkwWUBcUZUpMYU_WcD1QPEsmimCmPw/pub?embedded=true">here</a> (this has also been submitted as part of Assessment 2).
</p>

    </article>
    
  </body>
</html>